## 一、CSS

### **1、移动端1px 解决方案**

**概念**

-  CSS 像素
-  设备独立像素 = 逻辑像素，DIP，单位为 px。
-  不缩放情况下：1个CSS 像素=1个设备独立像素
-  设备像素 = 物理像素，分辨率，单位为 pt。
-  DPR（ 设备像素比，devicePixelRatio）= 物理像素 / 逻辑像素。

**造成边框变粗的原因**

- 因为 css 中的 1px 并不等于移动设备的 1px，这些由于不同的手机有不同的像素密度。
- 在`retina`屏的手机上， `dpr`为`2`或`3`，`css`里写的`1px`宽度映射到物理像素上就有`2px`或`3px`那么宽。
- 如 iPhone6 的`dpr`为`2`，物理像素`750`（x 轴）,则它的逻辑像素为`375`。 也就是说，1 个逻辑像素，在`x`轴和`y`轴方向，需要 2 个物理像素来显示，即：dpr=2 时，表示 1 个 CSS 像素由 4(2x2)个物理像素点组成
- 设计稿：750px，1px 边框====>想要的是物理像素的1px
- 我们：375px，1px 边框====>实际是CSS 像素的1px，被渲染成2px的物理像素，所以应该是 0.5px 边框

## CSS画0.5px的直线

**1、使用scale缩放**

```html
<style> 
    .hr.scale-half  {    
        height:1px;    
        transform:scaleY(0.5);/*Chrome/Safri都变虚了，只有Firefox效果和设置的0.5px一样*/
        transform-origin:50% 100%;/*加上transform-origin，效果正常*/
    } 
</style>    
<p>1px + scaleY(0.5)</p >      
<div  class = "hr scale-half" > </div> 
```

**2、linner-gradient**

```html
<style> 
    .hr.gradient  {    
        height:1px;    
        background:linear-gradient(0deg,#fff,#000);
    }
</style>
<p>linear-gradient(0deg, # fff,  #000)</p>
<div class= "hr gradient" > </div>
```

**3、box-shadow**

```html
<style> 
    .hr.boxshadow{
        height:1px;
        background:none;
        box-shadow:0 0.5 px 0 #000;
    }
</style>
<p>box-shadow: 0 0.5px 0 # 000 </p>
<div class="hr boxshadow"></div >
```

**4、viewport + rem**

在`devicePixelRatio = 2` 时，输出 viewport

```html
<meta
  name="viewport"
  content="width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"
/>
<!--效果等价于-->
<meta name="viewport" content="width=750, user-scalable=no" />
```

在`devicePixelRatio = 3` 时，输出 viewport

```html
<meta
  name="viewport"
  content="width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no"
/>
<!--效果等价于-->
<meta name="viewport" content="width=1125, user-scalable=no" />
```

### **2、opacity_visibility_display优劣**

+ **display：none;**
  + DOM 结构：不渲染、不占据空间
  + 事件监听：不能DOM 事件监听
  + 性能：引起重排，性能较差
  + 继承：不会被子元素继承
  + transition 不支持 display
+ **visibility: hidden;**
  + DOM 结构：渲染、占据空间
  + 事件监听：不能DOM 事件监听
  + 性能：引起重绘，性能较高；
  + 继承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏
  + transition：visibility 会立即显示，隐藏时会延时
+ **opacity: 0;**
  + DOM 结构：隐藏、占据空间
  + 事件监听：能DOM 事件监听
  + 性能：提升为合成层，不会触发重绘，性能较高；
  + 继承：会被子元素继承,且子元素并不能通过 opacity: 1 来取消隐藏；
  + transition：opacity 可以延时显示和隐藏

### **3、盒模型介绍**

- `box-sizing: content-box` ：标准盒模型（默认值），只包含 `content`。
- `box-sizing: border-box` ：IE（替代）盒模型，content + padding + border。

### **4、css 选择器和优先级**

 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

- 如果存在内联样式，那么 `A = 1`，否则 `A = 0` ；
- B 的值等于 `ID选择器（#id）` 出现的次数；
- C 的值等于 `类选择器（.class）` 和 `属性选择器（a[href="https://example.org"]）` 和 `伪类（:first-child）` 出现的总次数；
- D 的值等于 `标签选择器（h1,a,div）` 和 `伪元素（::before,::after）` 出现的总次数。

从左至右比较，如果是样式优先级相等，取后面出现的样式。

### 5、flex



### 6、line-height 如何继承？

- 父元素的 `line-height` 写了**具体数值**，比如 `30px`，则子元素 `line-height` 继承该值。
- 父元素的 `line-height` 写了**比例**，比如 `1.5 或 2`，则子元素 `line-height` 也是继承该比例。
- 父元素的 `line-height` 写了**百分比**，比如 `200%`，则子元素 `line-height` 继承的是父元素 `font-size * 200%` 计算出来的值。

### 7、DIV元素垂直居中

https://www.cnblogs.com/jiajia-hjj/p/14448156.html

1. translate(-50%，50%)；left、top 50%
2. 确认div宽度left、top 50%；margin为宽高一半的负值
3. left、top 、right、bottom:0；margin:auto
4. flex
5. flex布局和margin:auto
6. 父：display:table-cell;vertical-align:middle;text-align:center ；  子：display: inline-block; 
7. left、top:calc(父宽/高-子宽/高)/2

+ 

### 8、

### 9、BFC的形成和作用

+ BFC直译为"**块级格式化上下文**"。页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。
+ （一打开页面body就会创建出渲染的区域，这个渲染区域就是块级格式上下文。就是一个页面中划分的区域，专门按块级格式上下文的渲染方式，去渲染，这就是块级格式的渲染规则在里面起作用。）
+ 如何产生BFC？
  + 根元素，即HTML标签
  + float的值不为none。 
  + overflow的值不为visible。 
  + josition的值不为relative和static。
  + display的值为table-cell、table-caption、inline-block、flex中的任何一个。
+ 那BFC一般有什么用呢？
  + 比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。
+ IFC-内联格式化上下文，GFC-网格布局格式化上下文，FFC-自适应格式化上下文

### 10、CSS预处理器

### 11、em 、rem 、px 、vh、vw

+ px ：绝对长度单位
+ **%**：百分比
+ em：相对长度单位，参照物是父级元素的字体大小
+ rem：相对长度单位，参照物是根元素，支持ie9+
+ vw：相对于视口*宽度的百分比（100vw即视窗宽度的100%）
+ vh：相对于视口*高度的百分比（100vh即视窗高度的100%）

### 12、父子边距重合

+ 在父元素上加overflow:hidden;使其成为BFC

### 13、padding、margin百分比单位参考的依据

+ 父元素盒子的宽度

### 14、清除浮动的方法

+ 清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。

在CSS中，clear属性用于清除浮动，其基本语法格式如下：

```
选择器{clear:left|right|both;}   clear 清除 
```

**方法一：额外标签法**

```html
是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 
<div style=”clear:both”></div>，或则其他标签br等亦可。
```

优点： 通俗易懂，书写方便

缺点： 添加许多无意义的标签，结构化较差。  

**方法二：父级添加overflow属性方法**

可以通过触发BFC的方式，可以实现清除浮动效果。

~~~css
可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。
~~~

优点：  代码简洁

缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

**方法三：使用after伪元素清除浮动**

**3.1.使用:after 方式为空元素的升级版，好处是不用单独加标签了** 

使用方法：

```css
 .clearfix:after {  
     content: ""; 
     display: block; 
     height: 0; 
     clear: both; 
     visibility: hidden;
}   
 .clearfix {*zoom: 1;}   /* IE6、7 专有 */
```

优点： 符合闭合浮动思想  结构语义化正确

缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

代表网站： 百度、淘宝网、网易等

注意： content:""   尽量不带点

**3.2.使用before和after双伪元素清除浮动**

使用方法：

```css
.clearfix:before,.clearfix:after { 
  content:"";
  display:table;  /* 这句话可以出发BFC BFC可以清除浮动 */
}
.clearfix:after {
 clear:both;
}
.clearfix {
  *zoom:1;
}
```

优点：  代码更简洁

缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

代表网站： 小米、腾讯等响应式

### 15、响应式

**是什么**

+ 一个url可以响应多端

**方法**

+ 媒体查询：使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。
+ 百分比%：比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。
+ vw/vh：css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。
+ rem：rem单位是相对于字体大小的html元素，也称为根元素。 默认情况下，html元素的font-size为16px。所以此时1rem = 16px。
+ flex弹性布局：弹性布局只需要依赖于CSS样式的实现响应式布局的方式，也是最多用到的一种实现响应式的方法。

### 16、伪类和伪元素的区别

- 伪类只能使用`:`，伪元素既可以使用`:`，也可以使用`::`
- 伪元素其实相当于伪造了一个元素，伪类没有伪造元素，例如first-child只是给子元素添加样式而已。（本质区别就是**是否抽象创造了新元素**）

### 17、+` 和 `~` 选择器有什么区别？

+ 毗邻兄弟选择器 `+` 可以选择紧随元素后的所有同级元素。如：`div ~ p` 可以选择紧随 div 元素后且与其同级的 p 元素。
+ 一般兄弟选择器 `~` 可选择元素后的所有同级元素。如：`p ~ span` 将会匹配同一父元素下，p 元素后的所有 span 元素。

### 18、CSS父子边距重合

```html
<style>   
    .parent{    
        background:  #e7a1c5;  
    }  
    .parent .child  {    
        background:#c8cdf5;    
        height:  100px;    
        margin-top:10px;  
    } 
</style>
<section class="parent">  
    <article class="child"></article >   
</section>
```

+ 在这里父元素的高度不是110px，而是100px，在这里发生了高度坍塌。

**产生原因：**

如果块元素的 `margin- top` 与它的第一个子元系的 `margin - top` 之间没有 `border 、 padding、inlinecontent 、 clearance` 来分隔，或者块元素的 `margin- bottom` 与它的最后一个子元素的 `margin-bottom` 之间没有 border 、 paddind、 inlinecontent 、 height 、 min - height 、 max - height  分隔，那么外边距会塌陷。子元素多余的外边距会被父元素的外边距截断。

**解决办法：**

父子元素的边界重叠得解决方案：在父元素上加上 overflow : hidden ；使其成为 BFC 。



### background-position:百分比

`background-position:50% 20%；`

`图片宽度：imgWidth=100px  高度：imgHeight=100px；`

`容器宽度：conWidth=200px  高度：conHeight=200px;`

`x(距离容器的水平距离)=(conWidth-imgWidth)*50%=50px`

`y(距离容器的垂直距离)=(conHeight-imgHeight)*20%=20px`

### 怎么让Chrom支持小于12px的文字

+ zoom，改变页面元素的尺寸，不是标准属性，有兼容性问题

```css
.span1 {        
    font-size:12px;        
    display:inline-block;        
    zoom:0.8;    
}
```

+ `-webkit-transform:scale(0.8)`。scale属性只对可以定义宽高的元素生效

```css
.span1 {        
    font-size:  12 px;        
    display:inline - block;         
    -webkit-transform:scale(0.8);    
} 
```

+  `-webkit-text-size-adjust:none;` 。根据设备来自动调整显示大小。chrome27之后取消了。而且只对英文数字生效，对中文不生效

```css
html  { 
    -webkit-text-size-adjust:none; 
}

```

###  css像素、设备像素、设备独立像素、dpr、ppi

+ 设备独立像素 = 逻辑像素，DIP，单位为 px。
+ 不缩放情况下：1个CSS 像素=1个设备独立像素
+ 设备像素 = 物理像素，分辨率，单位为 pt。
+ 设备像素由屏幕生产之后就不发生，而设备独立像素是一个虚拟单位会发生改变
+ PC 端中，1个设备独立像素＝1个设备像素（在100%，未缩放的情况下）
+ 在移动端中，标准屏幕（160ppi)下1个设备独立像素＝1个设备像素
+ 设备像素比( dpr )＝设备像素／设备独立像素
+ 每英寸像素（ ppi )，值越大，图像越清晰

### link 与＠ import 的区别

+ link 是 HTML 方式，@import 是 CSS 方式
+ link最大限度支持并行下载，@ import过多嵌套导致串行下载，出现 FOUC(闪烁)
+ link可以通过 rel =" alternate stylesheet ＂指定候选样式
+ 浏览器对link支持早于@import ，可以使用@import 对老浏览器隐藏样式
+ @import 必须在样式规则之前，可以在 css 文件中引用其他文件
+ 总体来说： link 优于＠ import 

### 不要使用＠import 

+  css 样式文件有两种引入方式，一种是`link`元素，另一种是`@import` 
+  `@import` 会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时
+  而且多个`＠import` 可能会导致下载顺序紊乱
+  比如一个 css 文件 `index.css` 包含了以下内容：`@import url("reset.css")`
+  那么浏览器就必须先把 index . css 下载、解析和执行后，才下载、解析和执行第二个文件`reset.css`

### 怪异盒模型和标准盒模型

 标准盒  `box-sizing:content`大小计算公式：`width(content) + padding + border + margin` 

 怪异盒 `box-sizing:border-box`大小的计算公式：`width(content + padding + border) + margin`   

## 二、html



## 06.列出常见的行内元素、块级元素、空(void)元素？

**块级元素**  block

```html
<div > 、 <p > 、 <h1 > ... < h6 > 、 <ol > 、 <ul > 、 <dl > 、 <table > 、 <address > 、 < blockquote >  、 <form >
```

**行内(内联)元素**  inline

```html
<a> 、 <span> 、 <br> 、 <i> 、 < em > 、 < strong > 、 <label> 、 <q> 、 <var> 、 < cite> 、 <code>
```

**内联块状元素** inline-block

```html
<img> 、 < input >
```

**空(void)元素**，即系没有内容的HTML元素

```html
<br/>、 <hr/>、 <img/>、<input/>、<link/>、<meta/>、< br/>
```

## 

### 2、行内元素和块级元素的区别

**行内元素**

1. 设置宽高无效
2. 对margin设置左右方向有效，而上下无效；padding设置左右方向有效，而上下无效。
3. 不会自动换行

**块级元素**

1. 可以设置宽高，宽度有继承关系
2. 设置 margin 和 padding 都有效
3. 可以自动换行
4. 多个块状，默认排列从上到下

### **3、如何理解 HTML 语义化？**

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

### **4、script 标签中 defer 和 async 的区别？**

+ `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
+ `async script` ：当浏览器遇到带有 async 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码。所以有可能会阻断 HTML 的解析。
+ `defer script`：完全不会阻碍 HTML 的解析，当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码。

**总结：**

+ 把带 `defer` 属性的脚本放在 `<head>` 中比无属性的脚本放在 `<body/>` 之前要更好，因为浏览器在页面解析时可对带 `defer` 属性的脚本进行下载。
+ 如果脚本相互依赖，请使用 `defer`。
+ 如果脚本是独立的，请使用 `async`。
+ 如果 DOM 必须解析好才执行且执行函数没有放在 `DOMContentLoaded` 的监听器中，请使用 `defer`。

> [图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

### 5、iframe的优点、缺点

一、iframe的优点：
1、iframe能够原封不动地把嵌入的网页展现出来。

2、如果有多个网页调用iframe，只需要修改iframe的内容，就可以实现对调用iframe的每一个页面内容的更改，方便快捷。

3、网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性。

4、如果遇到加载缓慢的第三方内容如图标和广告等，可以用iframe来解决。



### 图片标签中的 alt 有什么作用？

+ 当图片无法加载的时候， alt 的属性值会以文字的形式替代图片显示。
+ alt 属性是用来描述图片内容的，当图片作为背景等装饰时，alt 属性应该为空。

- 网站爬虫根据其属性值来理解图片的内容，因此 alt 属性对 SEO（搜索引擎优化） 来说非常重要
- alt 值应以句号结尾，以提高可访问性

- 网速过慢导致图片加载需较长一段时间时，在图片加载完成之前，会显示 alt 属性值来替代图片。



### 清缓存的目的是什么，如何实现？

**缓存及优点**

+ 浏览器的缓存可以临时存储一些文件，因此当页面切换或者再次加载相同页面时就不需要去重新下载这些文件。
+ 服务端可以设置头部告诉浏览器在一定时间内存储这些文件。这样不仅可以大幅度加快网站的速度还可以节省你的带宽。

**缓存带来的问题**

+ 然而当开发者对站点进行修改时就可能会带来一些问题：某些用户可能仍在访问那些修改之前的文件。
+ 这样就会导致那些用户使用以前的功能或者访问一个坏了的站点（当服务端渲染的页面元素被删除、移动或重命名后，那些被缓存的 CSS 和 JavaScript 文件对这些元素的操作就会出现错误）

**解决方案**

+ 解决缓存的关键就是强制让浏览器下载最新的文件。这只需要给那些旧的文件一个新的名字，或者修改服务端的头部。
+ 比较简单常用的技术就是在文件结尾添加一个查询字符串，使其强制让浏览器重新下载新的文件。如下所示：

```
src="js/script.js"
src="js/script.js?v=2"

```

+ 这样一来，在不需要修改文件名的前提下，浏览器就会将其视为不同的文件。

**扩展**

- 服务端头部相关设置为 ETag（协商缓存）
- Service Workers及 Cache Storage（强制缓存）
- 网站的速度很大程度上会影响 SEO 评分
- 缓存和命名被誉为编程届的两大难题
- 使用 webpack 相关的项目在框架层面上已经比较完美的自动解决此问题

### 01.简述一下src与href的区别

**src**---用于替换当前元素；**href**----用于在当前文档和引用资源之间确立联系。

**src**（source）

+ 指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置。

+ 因此浏览器在解析src时，会停下来对后续文档的处理，直到src的内容加载完毕。
+ 常用在img、iframe、video、audio、script等标签中。
+ 这也就是为什么我们建议js文件放在HTML文档的最后面。如果js文件放在了head标签中，可以使用window.onload()方法，实现js的最后加载。

**href**（Hypertext Reference）

+ 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。。
+ 在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下执行。
+ 通常在a、link等标签中使用。

### 02.如何禁止a标签跳转页面或者定位链接？

**1、标签属性href，使其指向空或者不返回任何内容**

```html
<a  href = "javascript:void(0);"  > 点此无反应javascript: void(0) </a>
<a href="javascript:;" >点此无反应javascript:</a >

```

**2、阻止默认事件**

+ return false;

return false

```html
<a href = "" onclick = "return false;" >return  false; < /a><a href="#" onclick="return false;">return false;</a >

```

+ js文件中阻止默认点击事件：

```js
Event.preventDefault()

```

### 03.html 和css中图片加载与渲染规则是什么样的？

**图片加载和渲染的时机有可能是面这样：**

+ 解析 HTML 时，如果遇到 img 或 picture 标签，将会加载图片
+ 解析加载的样式，遇到 background-image 时，并不会加载图片，而会构建样式规则树
+ 加载 JavaScript ，执行 JavaScript 代码，如果代码中有创建 img 元素之类，会添加到 DOM 树中；如查有添加 background - image 规则，将会添加到样式规则树中
+ DOM 树和样式规则匹配时构建渲染树，如果 DOM 树节点匹配到样式规则中的 backgorund- image ，则会加载背景图片
+ 计算元素（图片）位置进行布局
+ 开始渲染图片，浏览器将呈现渲染出来的图片

 **Web 页面中不是所有的图片都会加载和渲染！根据前面介绍的浏览器加载和渲染机制，我们归纳为：**

+ `< img >、< picture ＞`和设置 `background - image` 的元素遇到 display : none 时，图片会加载但不会渲染；
+ `< img >、< picture ＞`和设置 `background - image` 的元素祖先元素设置 display : none 时， background - image 不会渲染也不会加载，而 img 和 picture 引入的图片不会渲染但会加载
+ `< img >、< picture >`和 `background - image` 引入相同路径相同图片文件名时，图片只会加载一次
+ 样式文件中 `background - image` 引入的图片，如果匹配不到 DOM 元素，图片不会加载
+ 伪类引入的 `background - image` ，比如： hover 只有当伪类被触发时，图片才会加载



### 04.什么是渐进增强和优雅降级？

**渐进增强**：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

**优雅降级**：一开始就构建站点的完整功能，然后针对低版本浏览器进行兼容。



**区别：**

a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给

b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要

c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。



### 05.Js 动画与 CSS 动画区别及相应实现

**CSS3的动画**

优点

+ 在性能上会稍微好一些，浏览器会对CSS3的 动画做一些优化。
+ 代码相对简单

缺点

+ 在动画控制上不够灵活
+ 兼容性不好

**JavaScript 的动画**

正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。

对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS。

### style 标签写在 body 后与 body 前有什么区别？

+ 页面加载自上而下当然是先加载样式。
+ 写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）

###  Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？

 **Doctype 作用**

Doctype DOCTYPE 位于文档的最前面，html标签之前，告诉浏览器以何种方式解析该文档，这里有两种模式，严格模式和混杂模式。

**区别：**

不同的文档模式主要影响css的呈现，尤其是盒模型的解析。

+ 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。一般以标准模式呈现页面。
+ 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

**意义：**
浏览器根据doctype是否存在以及使用的哪种DTD来选择要使用的呈现方式，如果存在完整的doctype则以标准模式呈现页面，不存在或者是形式不正确则会导致页面以混杂模式呈现。

### HTML 中可以包含多个 `<header>` 或者 `<footer>` 元素吗？

可以。因此不仅 ` <body> ` 可以包含头部和页脚， ` <article> ` 和 ` <section> ` 同样也可以。

```html
<body>
    <header>...</header>
    <section>
        <header>...</header>
        <footer>...</footer>
    </section>
    <section>
        <header>...</header>
        <footer>...</footer>
    </section>
    <footer>...</footer>
</body>

```

### `rel="noopener"` 应在什么场景下使用，为什么？



+ `rel="noopener"` 是    `<a> ` 超链接标签的一个属性。他可以禁止打开的新页面中使用 `window.opener` 属性，这样一来打开的新页面就不能通过 `window.opener` 去操作你的页面。

+ 因此 `rel="noopener"` 应在打开新页面的场景下使用，否则就会导致严重的安全漏洞(CSRF)。如新页面可以通过 `window.opener.location = newURL` 将你的页面导航至任何网址。



- 当你的页面链接至使用 `target="_blank"` 的另一个页面时，新页面将与你的页面在同一个进程上运行。 如果新页面正在执行开销极大的 JavaScript 时，那么你的页面性能可能会受到影响。
- 如果使用 JavaScript 打开的页面，可以通过如下代码解决：

```
var hacpaiWindow = window.open('https://hacpai.com');
hacpaiWindow.opener = null;

```



### 解释 MIME type 及其作用

`MIME` 是多用途 Internet 邮件扩展（`Multi-purpose Internet Mail Extensions`）的首字母缩写。 他使用标准化的方式来表示网络之间传输的文档类型及格式。完整格式可查看 [Media Types](https://link.ld246.com/forward?goto=https%3A%2F%2Fwww.iana.org%2Fassignments%2Fmedia-types%2Fmedia-types.xhtml)。

- MIME type 由两部分组成：斜杠（/）分隔的类型和子类型，中间无空格。例如：Microsoft Word 文件的 MIME type 是 `application/msword`，即类型是 application，子类型是 msword。
- 浏览器通常使用 MIME type 替代文件扩展名来确定文档类型，因此服务器在响应头中设置正确的 MIME type 是非常重要的。
- MIME type 对大小写不敏感，但是一般都使用小写。
- 对于 `text` 类型若没有指定其子类型就使用 `text/plain`；对于二进制文件没有指定其子类型就使用 `application/octet-stream`。
- 所有的 `text/*script*` 类型已被废弃。
- 当 MIME type 缺失或错误时，浏览器可能会查看资源以确定文件类型。我们可以通过设置 `X-Content-Type-Options` 为 `nosniff` 来阻止浏览器对 MIME type 的嗅探。
- 不同类型的文件可以通过查看二进制来判断其类型，但并非所有文件都如此。如：PNG 文件头标识 (8 bytes)  89 50 4E 47 0D 0A 1A 0A；GIF 文件头标识 (6 bytes)  47 49 46 38 39(37) 61。



### CSS 预处理器有什么优势？

+ CSS 预处理器添加了一些实用的原生 CSS 没有的的功能，并且他通过使用 DRY（Don't Repeat Yourself）原则使生成的 CSS 更加整洁和易于维护。
+ 他通过简洁的嵌套选择器语法减少了大量重复代码。
+ 变量、颜色函数（`lighten`,`darken`,`transparentize` 等）等附属工具，mixins 及循环使得 CSS 更像一个真正的编程语言，这使开发者编写复杂的 CSS 更加容易了。

**总结**

- CSS 预处理器虽然允许我们编写易于维护和可扩展的 CSS，但也存在一定的缺陷，如：需要安装、配置、编译等
- CSS 预处理器还包含文件切分、模块化、运算、函数等优势
- 目前主流的 CSS 预处理器有： [Sass](https://link.ld246.com/forward?goto=https%3A%2F%2Fsass-lang.com%2F)、[Less](https://link.ld246.com/forward?goto=http%3A%2F%2Flesscss.org%2F)、[Stylus](https://link.ld246.com/forward?goto=http%3A%2F%2Fstylus-lang.com%2F)
- CSS 除了预处理器外还有后置处理器（Postprocessor），如：[Autoprefixer](https://link.ld246.com/forward?goto=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer) 等
- CSS 变量虽然已被大多数浏览器支持，但语法及可用性都不如 CSS 预处理器。如：

```css
:root {
  --global-color: #666;
  --pane-padding: 5px 42px;
}
.demo{
   color: var(--global-color);
}

```

### CSS sprites 的优点及如何使用？

+ CSS sprites 将多张图片合并为一张图片，从而减少浏览器对 HTTP 的请求数量，进而减少网页的加载时间。

+ 在 HTTP/1.1 中，每个 TCP 连接只允许一个请求。现代浏览器虽然可以打开多个（2-8）并行的 TCP 连接，但连接数量依旧有限。

+ 想要在 CSS 中使用 sprites 需要用到 CSS 中的 `background-image`、`background-position` 及 `background-size` 属性，他们可以通过改变元素背景的图片、位置及大小来达到预期的效果。

- CSS Sprite 可以使用 [Gulp](https://blog.csdn.net/weixin_45426836/article/details/109066884) 或 [Webpack](https://blog.csdn.net/qq_44770878/article/details/125052152) 等工具减轻图片重构、像素调整的困扰
- [为什么使用 SVG 可以提升网页性能和体验](https://link.ld246.com/forward?goto=https%3A%2F%2Fhacpai.com%2Farticle%2F1464879728790)
- [如何实现 SVG sprites](https://link.ld246.com/forward?goto=https%3A%2F%2Fhacpai.com%2Farticle%2F1495879561322)



### 使用 flexbox，创建一个 3 列布局，其中每列占据容器的 col-{n} / 12 比率

设置父容器为 `display: flex`，然后使用 `flex` 为每列提供与其比值相对应的 `flex-grow` 值。

```html
<style lang="scss">
.row {
  display: flex;
  &__col {
    ...
    &--2 {
      flex: 2
    }
    &--7 {
      flex: 7
    }
    &--3 {
      flex: 3
    }
  }
}
</style>
<div class="row">
  <div class="row__col row__col--2"></div>
  <div class="row__col row__col--7"></div>
  <div class="row__col row__col--4"></div>
</div>

```

## 三、js

### **1、this指向问题**

+ 普通函数：指向它的**调用者**
  + 在默认情况下：没找到直接调用者，this指向window。
  + 在严格模式下：没找到直接调用者，绑定到 undefined 
  + `apply`、`call`或`bind`，函数内的 this ，就是作为参数传入这些方法的对象
  + `new`关键字，`this`是一个新创建的对象
+ 箭头函数：不看调用者。而是看定义它时**所在的作用域**，箭头函数本身不存在this，所以它的this指向上一层作用域所在的对象。
  + 不能作为构造函数
  + 不能使用arguments对象
  + 不能使用yield命令

```js
function foo(){
    console.log(this.a)
}
function doFoo(fn){
    console.log(this)
    fn()
}
var obj={a:1,foo}
var a=2;
doFoo(obj.foo) 
//打印出：window 2

```

```js
function foo(){
    console.log(this.a)
}
function doFoo(fn){
    console.log(this)
    fn()
}
var obj={a:1,foo}
var a=2;
//改变doFoo指向
doFoo.call(obj,obj.foo) 
//打印出：obj 2

```

```js
function foo(){
    console.log(this.a)
}
function doFoo(fn){
    console.log(this)
    fn.call(this)
}
var obj={a:1,foo}
var a=2;
//改变doFoo指向
doFoo.call(obj,obj.foo) 
//打印出：obj 1

```

### 2、什么时候用箭头函数

**为何用？**

更简短的函数，并且不绑定`this`

+ 普通函数，每个新定义的函数都有它自己的`this`值
  + 构造函数，是一个新对象
  + 严格模式的函数调用中，则为undefined
  + 作为"对象方法"调用则为基础对象
+ 箭头函数，没有它自己的执行上下，**这就意味着代码中的`this`和`arguments`都是继承它的父函数**。
  + 通过call或者apply调用，只能传递参数(不能绑定this)

**何时用？(不推荐使用场景)**

+ 不能使用new操作符，创建构造函数
+ 不能使用arguments对象

+ 不能用prototype属性

+ 不能使用yield关键字

https://segmentfault.com/a/1190000020134330



### 3、箭头函数和普通函数有什么区别

1. 箭头函数中的this是在定义时就决定的，而且是不可修改的（call、apply、bind）；
2. 箭头函数不能用于构造函数（不能new）：普通函数可以用于构造函数，以此创建对象实例；
3. 箭头函数不具有 prototype 原型对象；
4. 箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个 arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象；

###  4、call、apply、bind有什么区别？

+ https://www.cnblogs.com/jiajia-hjj/p/15867092.html
+ 都是用来改变函数的this对象的指向的；
+ 第一个参数都是this要指向的对象，也就是想指定的上下文，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。
+ 都可以利用后续参数传参，apply第二个参数是个数组，call和bind都是以逗号分隔。apply和call是一次性传入参数，而bind可以分为多次传入。
+ bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即调用 。

### **5、改变this的指向**

+ call、apply、bind可以改变this的指向

### 6、**基础的数据类型有哪几种**

https://www.cnblogs.com/jiajia-hjj/p/15214043.html

+ 8 种基础的数据类型，Number、Undefined、Boolean、Null、String、Object、Symbol、BigInt
+ Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
+ BigInt 可以表示任意大小的整数。原来最大是2^-13^  ~2 ^13^ 

### 7、值类型和引用类型的理解

+ 值类型是直接存储在**栈（stack）**中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
+ 引用类型存储在**堆（heap）**中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；栈中存储内存地址。



### 8、数据类型的判断

+ **typeof**：能判断所有**值类型，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object` 。

```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object


```

- **instanceof**：能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**

```js
class People {}
class Student extends People {}

const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true


```



- **Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

```js
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"


```



### 9、**如何判断变量是否为数组**

```javascript
//1、Array.isArray()----ES5新增的方法
Array.isArray(arr); // true
//2、原型链
arr.__proto__ === Array.prototype; // true
//3、instanceof
arr instanceof Array; // true
//4、Object.prototype.toString.call
Object.prototype.toString.call(arr); // "[object Array]"

```

### 10、JavaScript数字精度丢失问题

https://www.cnblogs.com/jiajia-hjj/p/15938311.html

+ **进制转换**，二进制浮点运算，尾数最大可以存储 53 位有效数字，大于 53 位后面的会全部截掉，将导致精度丢失。
+ **对阶运算**：阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况

+ 解决的整体思想是，大整数运算--->BigInt；小数运算---->把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）

### 11、**深拷贝、浅拷贝**

**赋值和深/浅拷贝的区别**

- 当我们把一个对象赋值给一个新的变量时，**赋的其实是修改对象的在栈中的地址，而不是堆中的数据**。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。
- 深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

https://www.cnblogs.com/jiajia-hjj/p/15271760.html

**浅拷贝**

+ 对象
  +   ...实现 
  +   Object.assign()
  +   for in实现 

+ 数组

  + ...实现 
  + Array.from实现 
  + forEach实现 
  + map实现 
  + slice()
+ 函数库lodash的_.clone方法

**深拷贝**

- JSON.parse(JSON.stringify())，局限：函数不能复制；原型链搞没了...
- 函数库lodash的_.cloneDeep方法
- jQuery.extend()方法
- 手写递归拷贝

+ **方法二：递归拷贝**

```js
//普通递归版本
function deepClone(obj){
    if(typeof obj!="object"){
        return obj;
    }
    let result = obj instanceof Array ||Object.prototype.toString.call(obj)==="[Object Array]"?[]:{};
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            result= deepClone(obj[key]);
        }
    }
    return result;
}
// 解决循环引用问题的版本
function deepClone(obj={},map=new Map()){
    if(typeof obj!="object"){
        return obj;
    }
    if(map.get(obj)){
        return map.get(obj)
    }
    let result={};
    if(obj instanceof Array ||Object.prototype.toString.call(obj)==="[Object Array]"){
        result=[];
    }
    map.set(obj,result);
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            result= deepClone(obj[key],map);
        }
    }
   return result;
}
```



### 

1. 

### 12、构造函数

+ 是一种特殊的函数。主要用来在创建对象时初始化对象。
+ 构造函数用于创建一一类对象，首字母要大写。
+ 构造函数要和new一起使用才有意义。
+ **好处**：代码的简洁性，识别对象的具体类型。

### 13、new关键字

+ 在内存中创建一个新的空对象
+ 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。
+ 让构造函数的this指向这个新的对象，执行构造函数。目的：给这个新对象加属性和方法
+ new会返回这个新对象



```js
function myNew(context) {
    const obj =new Object();
    obj.__proto__=context.prototype;
    let res=context.apply(obj,[...arguments].slice(1));
    console.log([...arguments]);// [ƒ, 'hjj', '18']
    return typeof res=="object"?res:obj;
}

function Person(name,age){
    this.name=name;
    this.age=age
}
//实例
let p1=myNew(Person,'hjj','18');//==>Person {name: 'hjj', age: '18'}

```

### 14、原型和原型链

https://www.cnblogs.com/jiajia-hjj/p/15376992.html

1. 当一个对象查找属性和方法时会从自身查找，如果查找不到则会通过`__proto__`指向被实例化的构造函数的prototype
2. 隐式原型也是一个对象，是指向我们构造函数的原型
3. 除了最顶层的Object对象没有`__proto__`，其他所有的对象都有`__proto__`，这是隐式原型
4. 隐式原型`__proto__`的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的`__proto__`属性，它的值是null，这个查找的过程就是原型链

**1）`__proto__`、`prototype`**

+ 实例对象中有**`__proto__`**属性，叫原型，是一个对象，是给浏览器使用，不是标准的属性----->可以叫原型对象。
+ 任何函数中有 `prototype` 属性，叫原型，是一个对象，是给程序员使用，是标准的属性---->可以叫原型对象。。constructor属
+ 函数也是对象，所以也有`__proto__`属性

**2）prototype（真正原型）**

+ 每一个构造函数都有一个 `prototype` 属性，是一个对象。
+ `prototype`对象的所有属性和方法，都会被构造函数的实例继承。
+ 所有对象实例需要共享的属性和方法，直接定义在 `prototype` 对象上。

**3）构造函数、实例、原型三者之间的关系**

+ 每一个构造函数都有一个 `prototype` 属性，是一个对象。
+ 构造函数的 `prototype` 对象默认都有一个 `constructor` 属性，指向 `prototype` 对象所在函数。

```js
console.log(F.constructor === F) // => true
console.log(F.prototype.constructor === F) // => true

```

+ 实例对象中有`__proto__`属性，是一个对象，指向构造函数的 `prototype` 对象

```js
实例对象.__proto__===构造函数.prototype

```

+ 实例对象可以直接或间接继承了原型对象成员。

**4）constructor 属性**

```js
function Person() {}
var p1 = new Person();
//1、constructor 是构造函数中`prototype`属性的成员，指向 `prototype` 对象所在函数。
console.log(Person.prototype.constructor === Person) // => true
//2、实例对象中有`__proto__`属性，会指向构造函数中prototype对象。
console.log(p1.__proto__ === Person.prototype) // => true
//3、所以实例对象也继承了原型对象的成员constructor属性。
console.log(p1.constructor === Person.prototype.constructor) // => true
console.log(p1.constructor) // 返回构造函数本身=> Person

```

**5）判断实例和构造函数的关系**

```js
console.log(p1.constructor === Person) // => true
//instanceof操作符,检测对象的类型更可靠
console.log(p1 instanceof Person) // => true

```

**6）原型链**

>  原型链是一种关系,实例对象和原型对象之间的关系,关系是通过原型(`__proto__`)来联系的

**属性成员的搜索原则：原型链**

+ 实例对象使用属性或方法时，先在**实例本身**中查找，找到了则直接使用
+ 找不到，则沿着原型链向上查找，（去实例对象的`__proto__`指向的**原型对象`prototype`**中找），找到了则使用。
+ 如果一直到原型链的末端还没有找到，则返回 `undefined`

```js
function Person() {

}
var person = new Person();
//原型链
person.__proto__  ===Person.prototype;
Person.prototype.__proto__ ===Object.prototype;  //(构造函数Object())
Object.prototype.__proto__ === null

```



###  15、作用域与作用域链

https://www.cnblogs.com/jiajia-hjj/p/15219824.html

**作用域：**确定当前执行代码对变量的访问权限。（全局作用域、函数作用域、块级作用域）

**作用域链：**从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。

### 16、词法作用域

- 静态作用域(**词法作用域**)，函数的作用域在函数定义的时候就决定了。
  + **js 采用的是静态作用域。**
- **动态作用域**，与词法作用域相对。函数的作用域是在函数调用的时候才决定的。

```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???==>1
/*
**静态作用域：**
执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，
如果没有，就根据书写的位置，查找上面一层的代码，
也就是 value 等于 1，所以结果会打印 1。

**动态作用域**：
执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。
如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。


结果：js采用的是静态作用域，所以结果是 1。
*/

```

### 17、闭包

**闭包函数：**声明在一个函数中的函数，叫做闭包函数。

**闭包：**一个内层函数中访问到其外层函数的作用域

**应用场景**：缓存工具，隐藏数据，不被外界访问，只暴露api。(闭包--公用方法，内部变量--私有属性（private）)

**闭包的作用**

+ 访问其他函数内部变量
+ 保护变量不被内存回收机制回收
+ 避免全局变量被污染，方便调用上下文的局部变量，加强封装性
+ 长久的保存变量又不会造成全局污染。 

**闭包的缺点**

+ 闭包长期占用内存，内存消耗很大，可能导致内存泄露
+ 延长作用域链

### 18、call、apply、bind 实现原理

### 19、**数组的方法**

https://www.cnblogs.com/jiajia-hjj/p/15214050.html

转换方法：toString()、valueOf()、join()、Array.from()

+ Array.from()： 将一个类似数组或可迭代对象，转为一个新的数组。浅拷贝

栈方法：push()/pop()

队列方法：unshift()/shift()

排序方法：reverse()、sort()、

操作方法：concat()、slice()、splice()

位置方法：indexOf()、lastIndexOf()、

迭代方法：map()、reduce()、filter()、every()、some()、forEach()、find()、findIndex()

### find 和 filter 的区别

- filter 返回符合条件的所有内容结合成新数组，不会改变原数组
- find 返回符合条件的第一个内容，不会改变原数组

### some和every的区别

- some 条件满足一个即可返回true。。。一真为真
- every 条件需全部满足才可返回true。。。一假为假

### 20、数组响应式方法

+ push()/pop()
+ unshift()/shift()
+ splice()
+ sort 
+ reverse 

### 21、**数组去重**

https://www.cnblogs.com/jiajia-hjj/p/15024493.html

```js
function unique(arr){
    return [...new Set(arr)]
}

```

```js
function unique(arr){
    let newArr=[]
    arr.forEach((item)=> {
        if(newArr.indexOf(item)==-1){
            newArr.push(item)
        }
    })
    return newArr
}
function unique2(arr) {
    var obj = {};
    return arr.filter(ele => {
        if (!obj[ele]) {
            obj[ele] = true;
            return true;
        }
    })
}

```

### 22、**字符串的方法**

https://www.cnblogs.com/jiajia-hjj/p/15214059.html

+ 字符方法：charAt()、charCodeAt()、str[i]
+ 字符串操作方法：concat()、slice()、substring()、substr()、
+ 位置方法：indexOf()、lastIndexOf()、search()、match()
+ 去除空白：trim()
+ 大小写转换方法：toLocaleUpperCase()、toLocaleLowerCase()
+ replace()、split()、fromCharCode()

### 23、**内置对象-Math**

https://www.cnblogs.com/jiajia-hjj/p/15219743.html

```js
Math.PI			// 圆周率
Math.random()// 生成随机数，范围[0,1)
Math.floor()/Math.ceil()// 向下取整/向上取整
Math.round()	// 取整，四舍五入
Math.abs()		// 绝对值
Math.max()/Math.min()// 求最大和最小值

Math.sin()/Math.cos()// 正弦/余弦
Math.power()/Math.sqrt() // 求指数次幂/求平方根
//1-10随机数
Math.ceil(Math.random()*10)

```



### 24、**内置对象-Date**

https://www.cnblogs.com/jiajia-hjj/p/15219751.html

获取当前日期的毫秒数

```js
var date = new Date();
date.valueOf();
date.getTime();
Date.parse(data)
//HTML5中提供的方法，有兼容性问题
Date.now();

// 不支持HTML5的浏览器，可以用下面这种方式
var now = + new Date();	
console.log(now)//1630420547076	

```



### 25、**正则**

https://www.cnblogs.com/jiajia-hjj/p/15219729.html

### ['1', '2', '3'].map(parseInt) 

+ `parseInt(string, radix)` 将一个字符串转换为 `radix` 进制的整数。 

+ parseInt(100, 2); //4，(2进制,0x2^0^+0x2^1^+1x2^2)

+ ```js
  ['1', '2', '3'].map((item, index) => {
  	return parseInt(item, index)
  })
  
  ```

  即返回的值分别为：

  ```js
  parseInt('1', 0) // 1 (0:es5是十进制)
  parseInt('2', 1) // NaN 没有1进制
  parseInt('3', 2) // NaN, 3 不是二进制
  
  ```

##### 

12、创建对象的方式



### Object.is()和===区别

+ **Object.is(value1, value2)**：用来比较两个值是否严格相等，与（===）基本类似。


```js
//与（===）的区别
Object.is(+0,-0);  //false
+0 === -0  //true

Object.is(NaN,NaN); //true
NaN===NaN //false

```

### 说一下for...in 和 for...of的区别?

**数组：**

+ for…in…循环读取键名，而for…of…循环读取键值

```js
const arr = [1,2,3];
//且for...in...循环返回的是键名的字符串表达
for(let i in arr) {
    console.log(i)   // '0' , '1', '2'
}
for(let i of arr) {
    console.log(i)   //1,2,3
}

```

+ for…of…循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性，for…in…还会遍历手动添加的其他键

```js
const arr = [1,2,3];
arr.name = "array";
for(let i in arr){
    console.log(i)   // '0','1','2','name'
}
for(let i of arr){   //不会返回数组的name属性
    console.log(i)   // 1,2,3
}

```

**对象：**

+ 普通对象无法直接使用for…of…进行遍历，会报错；使用Object.keys()将对象的键名生成一个数组，然后遍历这个数组

```js
const obj = {
    name: 'Gary',
    age: 16
};
for( let i of Object.keys(obj)){
    console.log( i , obj[i])    //'name'  'Gary'
}                               //'age'  16


```

**总结**

+ for...in循环主要是为了遍历对象而生,不适用遍历数组；
+ for...of循环可以用来遍历数组、类数组对象、字符串、Set、Map以及Generator对象



### 数组的for…of…与forEach()的区别

+ forEach()无法中途跳出循环，break命令或return命令都不管用，甚至会报错

+ 但是for…of…可以与break continue return 配合使用

+ continue只是中止本次循环，接着开始下一次循环。

+ break用于完全结束一个循环，跳出循环体。 

### 说一下前端登录的流程?

+ 初次登录的时候，前端调后调的登录接口，发送用户名和密码
+ 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值
+ 前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中
+ 把用户信息存到Vuex然后再存储到LocalStroage中，然后跳转到下一个页面
+ 根据后端接口的要求，只要不登录就不能访问的页面，需要在前端每次跳转页面时判断Cookies中是否有token
+ 没有就跳转到登录页，有就跳转到相应的页面，
+ 我们应该再每次发送post/get请求的时候应该加入token，常用方法再项目utils/service.js中添加全局拦截器，将token的值放入请求头中 
+ 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token
+ 然后有个跳回登录页面重新登录并且清除本地用户的信息

### 说一下前端权限管理怎么实现

### 说一下购物车的逻辑?

```js
//vue中购物车逻辑的实现

1. 购物车信息用一个数组来存储，数组中保存对象，对象中有id和count属性

2. 在vuex中state中添加一个数据 cartList 用来保存这个数组

3. 由于商品详情页需要用到加入购物车功能，所以我们需要提供一个mutation, 用来将购物车信息加入 cartList中

4. 加入购物车信息的时候，遵照如下规则： 如果购物车中已经有了该商品信息，则数量累加，如果没有该商品信息，则新增一个对象

5. 在商品详情页，点击加入购物车按钮的时候，调用vuex提供的addToCart这个mutation将当前的商品信息 （id count）传给addTocart  this.$store.commit("addToCart", {id:  , count：})

// js中购物车逻辑的实现
1.商品页点击“加入购物车”按钮，触发事件

2.事件调用购物车“增加商品”的Js程序（函数、对象方法）

3.向Js程序传递传递“商品id”、“商品数量”等数据

4.存储“商品id”、“商品数量”到浏览器的localStorage中

**展示购物车中的商品******

1.打开购物车页面

2.从localStorage中取出“商品Id”、“商品数量”等信息。

3.调用服务器端“获得商品详情”的接口得到购物车中的商品信息（参数为商品Id）

4.将获得的商品信息显示在购物车页面。

**完成购物车中商品的购买******

1.用户对购物车中的商品完成购买流程，产生购物订单

2.清除localStorage中存储的已经购买的商品信息

备注1：购物车中商品存储的数据除了“商品id”、“商品数量”之外，根据产品要求还可以有其他的信息，例如完整的商品详情（这样就不用掉服务器接口获得详情了）、购物车商品的过期时间，超过时间的购物车商品在下次打开网站或者购物车页面时被清除。

备注2：购物车商品除了存储在localStorage中，根据产品的需求不同，也可以存储在sessionStorage、cookie、session中，或者直接向服务器接口发起请求存储在服务器上。何种情况使用哪种方式存储、有啥区别请自己分析。

```

#### 前端权限管理





## 四、Web API

### 1、页面加载事件

- onload

```javascript
window.onload = function () {
  // 当页面加载完成执行
  // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行
}

```

- onunload

```javascript
window.onunload = function () {
  // 当用户退出页面时执行
}

```

### 2、location对象

+ http://localhost:8080/new/index.html?ID=24618&page=1#r_70732423
+ scheme://host.domain:port/path/filename
+ 协议：//域名:端口号/服务器上的路径/文档的名称?参数#锚
+ 主机= 域名+端口号
+ 属性：
  + href->当前地址，跳转页面
  + protocol->协议，
  + host->主机，
  + hostname->主机的域名
  + port->端口号，
  + search->参数，
  + hash->锚点，
  + location.assign->加载新文档

### 3、history对象

路径变页面也变，页面刷新

- back() 前一个 URL。
- forward() 下一个 URL
- go() 某个具体页面

路径会变，但是页面不会变，页面不刷新

```js
history.pushState({},'','home') 
history.replaceState({},'','home') 

```

### 4、navigator对象

常用来判断设备

- userAgent：通过userAgent可以判断用户浏览器的类型
- platform：通过platform可以判断浏览器所在的系统平台类型.







## 五、ES6

### 1、var、let、const的区别

- var、let、const 共同点都是可以声明变量的
- var 具有变量提升的机制，let 和 const 没有变量提升的机制
- var 可以多次声明同一个变量，let 和 const 不能多次声明同一个变量
- var、let 声明变量，声明之后可以不赋值；const 声明常量，声明之后必须赋值
- var 和 let 声明的变量可以再次赋值，但是const不可以再次赋值
- var 声明的变量没有自身的作用域，let 和 const 是有自身的作用域的

### 2、let有什么用，有了var为什么还要用let？

+ 是因为ES5里面没有块级作用域是很不合理的
+ 没有块级作用域会带来很多难以理解的问题，比如for循环var变量泄露，变量覆盖等问题。
+ let 声明的变量**拥有自己的块级作用域**，且修复了var声明变量带来的**变量提升问题**。

### 3、let a='ss'存储在哪里

+ 使用 let 声明的全局变量不是挂在 window 对象下的，声明的全局变量存在于一个块级作用域中。

+ 在全局函数的 scope 下

### 4、map和foreach有什么区别

+ foreach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型
+ map()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值。

### 5、babel是什么，有什么作用?

+ babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台。

### 6、字符串startsWith|endsWith|padStart|padEnd|repeat

**重复字符串repeat**

```js
/*repeat() 返回一个新字符串,表示将原字符串重复 n 次 */ 
console.log('x'.repeat(3))     //xxx
console.log('hello'.repeat(2)) //hellohello
console.log('na'.repeat(0))    // ''
// 参数如果是小数, 会被x向下取整
console.log('na'.repeat(2.9))  //nana
// 如果repeat的参数是负数或者 Infinity,会报错
// console.log('na'.repeat(Infinity))
// console.log('na'.repeat(-1))
// 但如果参数是 0 到 -1 之间的小数,则等同于0, 这是因为会先取整运算.
```

**判断字符位置stratsWith|endsWith|includes**

```js
/*
 传统上,Javascript只有 indexOf() 方法可用来确定一个字符串是否包含在另一个字符串中.
    es6 又提供了 3 种新方法:
   1. includes()  返回布尔值,表示是否找到了参数字符串
   2. startWith() 返回布尔值,表示参数字符串是否在源字符串的头部
   3. endWith()   返回布尔值,表示参数字符串是否在源字符串的尾部
*/
var s = '1234567890'
console.log(s.startsWith('1234'))    // true
console.log(s.endsWith(0))           // true
console.log(s.includes('6'))         // true

// 这三个方法都支持第二个参数,表示开始搜索的位置

var s = 'Hello world!'
console.log(s.startsWith('world', 6))  // true
console.log(s.endsWith('Hello', 5))    // true ，前5 个字符中的尾部是Hello
console.log(s.includes('Hello', 0))    // true
// 使用第二个参数 n 时, endsWith 的行为与其他两个方法有所不同.它针对前 n 个字符,而其他两个方法针对从第 n个位置到字符串结束位置之间的字符

```

**字符串补全长度 padStart| padEnd**

```js
/*
es7 引入了字符串补全长度的功能.
如果某个字符串不够指定长度,会在头部或者尾部补全.
padStart()  用于头部补全
padEnd()    用于尾部补全   
*/
console.log('hello'.padStart(8, '01')) //  '010hello'  指定8位字符长度，不够，头部用01来补全
console.log('hello'.padStart(6, '01'))  //  '0hello'

console.log('hello'.padEnd(8, '01')) //  'hello010'  指定8位字符长度，不够，尾部用01来补全
console.log('hello'.padEnd(6, '01'))  //  'hello0'
```

### 7、举一些ES6对String字符串类型做的常用升级优化?

**优化部分：**ES6新增了字符串模`${}`，板反斜杠

**升级部分:**

+ ES6在String原型上新增了`includes()`方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 
+ 此外还新增了`startsWith(), endsWith(), padStart(),padEnd(),repeat()`等方法，可方便的用于查找，补全字符串。



### 8、数组copyWithin()| includes()| fill()|flat()

+ copyWithin()，复制数组的一部分数据覆盖到数组的另一个位置。并返回数组。会改变原数组。

```js
//arr.copyWithin(target[, start[, end]])
 var arr1=['a','b','c','d','e'];
//覆盖到从索引为0开始的元素,  复制的内容是[‘d’],
arr1.copyWithin(0,3,4)
console.log(arr1);//["d", "b", "c", "d", "e"]


var arr1=['a','b','c','d','e'];
//覆盖到从索引为1开始的元素,  复制的内容是[‘d’,‘e’]
arr1.copyWithin(1,3);
console.log(arr1);// ['a', 'd', 'e', 'd', 'e']
```

+ includes()用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。

```js
//arr.includes(searchElement, fromIndex)。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。
[1, 2, 3].includes(2);	//true
[1, 2, 3].includes(4);	// false
[1, 2, 3].includes(3, 3);	// false
[1, 2, 3].includes(3, -1);	//true  3+-1=2，索引2
[1, 2, NaN].includes(NaN);	//true
```

+ fill() 使用固定值来填充数组。会改变原来是数组

```js
//array.fill(value[, start[, end]])
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.fill("Runoob");//['Runoob', 'Runoob', 'Runoob', 'Runoob']

var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.fill("Runoob", 1, 2);//不包含end ['Banana', 'Runoob', 'Apple', 'Mango']
```

+ flat()，扁平化数组，不会改变原来是数组

```js
let arr = [1,2,3,[4,5,[6,7],8],9] 
arr.flat()//[1, 2, 3, 4, 5, [6,7], 8, 9]
```



### 9、举一些ES6对Array数组类型做的常用升级优化?

**优化部分：**

+  数组解构赋值。ES6可以直接以`let [a,b,c] = [1,2,3]`形式进行变量赋值，在声明较多变量时，不用再写很多let(var),且映射关系清晰，且支持赋默认值。
+  扩展运算符。ES6新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5中，arguments并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（`let a = [2,3,4]; let b = [...a]`）。

**升级部分:**

+ ES6在Array原型上新增了find()方法，用于取代传统的只能用indexOf查找包含数组项目的方法，且修复了indexOf查找不到NaN的bug(`[NaN].indexOf(NaN) === -1`).
+ 此外还新增了`copyWithin(), includes(), fill(),flat()`等方法，可方便的用于字符串的查找，补全,转换等。



### 10、Number数字类型isNaN、isInteger、isFinite

```js
//isNaN判断是不是NaN，
console.log(isNaN('number'))true


let a = 5;
//isFinite 判断是不是有限的数字，如果是，就返回true，不是就返回false。
console.log(Number.isFinite(a))    // 结果 true

let b = 452;
// isInteger 判断是不是整数，如果是整数就返回true，不是就false。
console.log(Number.isInteger(b));
```

### 11、举一些ES6对Number数字类型做的常用升级优化?

**优化部分：**

+ ES6在Number原型上新增了`isFinite(), isNaN()`方法，用来取代传统的全局`isFinite(), isNaN()`方法检测数值是否有限、是否是NaN。
+ ES5的`isFinite(), isNaN()`方法都会先将非数值类型的参数转化为Number类型再做判断，这其实是不合理的，最造成`isNaN('NaN') === true`的奇怪行为--'NaN'是一个字符串，但是isNaN却说这就是NaN。
+ 而Number.isFinite()和Number.isNaN()则不会有此类问题(`Number.isNaN('NaN') === false`)。（isFinite()同上）

**升级部分:**

+ ES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算。

### 举一些ES6对Object类型做的常用升级优化?(重要)

**优化部分：**

**1、对象属性变量式声明。**

+ ES6可以直接以变量形式声明对象属性或者方法。
+ 比传统的键值对形式声明更加简洁，更加方便，语义更加清晰。

```js
let [apple, orange] = ['red appe', 'yellow orange'];
let myFruits = {apple, orange};    // let myFruits = {apple: 'red appe', orange: 'yellow orange'};
```

尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显:

```js
let {keys, values, entries} = Object;
let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values, entries: entries}
```

可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法：

```js
let es5Fun = {
    method: function(){}
}; 
let es6Fun = {
    method(){}
}
```

**2、对象的解构赋值。**

+ ES6对象也可以像数组解构赋值那样，进行变量的解构赋值：

```js
let {apple, orange} = {apple: 'red appe', orange: 'yellow orange'};
```

**3、对象的扩展运算符(...)。**

+ 对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解。

```js
let {apple, orange, ...otherFruits} = {apple: 'red apple', orange: 'yellow orange', grape: 'purple grape', peach: 'sweet peach'}; 
// otherFruits  {grape: 'purple grape', peach: 'sweet peach'}
// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最后一个参数(otherFruits后面不能再跟其他参数)
let moreFruits = {watermelon: 'nice watermelon'};
let allFruits = {apple, orange, ...otherFruits, ...moreFruits};
```

**4、super 关键字。**

+ ES6在Class类里新增了类似this的关键字super。
+ 同this总是指向当前函数所在的对象，不同super关键字总是指向当前函数所在对象的原型对象。
+ this : 代表当前自身类的对象,可以调用当前类的构造方法,成员变量和成员方法等
+ super : 代表对父类的引用 , 可以调用父类构造方法,成员变量和方法
+ 但是它们都不能在静态方法里使用

**升级部分:**

**1、is()方法**

+ 做两个目标对象的相等比较
+ 用来完善'`===`'方法'`===`'方法中`NaN === NaN //false`其实是不合理的
+ (`Object.is(NaN, NaN) // true`)

**2、assign()方法**

+ 用于对象新增属性或者多个对象合并。

```js
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```

+ 注意: assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行get/set函数，取return的值）。

**3、getOwnPropertyDescriptors()方法**

+ 此方法增强了ES5中getOwnPropertyDescriptor()方法，
+ 可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性。

**4、getPrototypeOf()和setPrototypeOf()方法**

+ 用来获取或设置当前对象的prototype对象。
+ 这个方法存在的意义在于，ES5中获取设置prototype对像是通过`__proto__`属性来实现的，然而`__proto__`属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的prototype对象时，都应该采用ES6新增的标准用法。

**5、ES6在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法**

+ 用来获取对象的所有键、所有值和所有键值对数组。

### 举一些ES6对Function函数类型做的常用升级优化?(重要)

**优化部分：**

1、箭头函数**(核心)**。没有自己的this。主要优化点:

+  **箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象**。

+  箭头函数不能用作构造函数，因为它没有自己的this，无法实例化。

+  也是因为箭头函数没有自己的this,所以箭头函数 内也不存在arguments对象。（可以用扩展运算符代替）

2、函数默认赋值。ES6之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6以更简洁更明确的方式进行函数默认赋值。

```js
function es6Fuc (x, y = 'default') {
    console.log(x, y);
}
es6Fuc(4) // 4, default
```

**升级部分:**

+ ES6新增了双冒号运算符，用来取代以往的bind，call,和apply。(浏览器暂不支持，Babel已经支持转码)

```js
foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
复制代码
```

### Symbol是什么，有什么作用？

+ Symbol是ES6引入的第七种数据类型，所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。
+ 对象中Symbol()属性不能被for...in遍历，但是也不是私有属性。

### Set是什么，有什么作用？

+ Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员
+ 区别是Set实例的成员都是唯一，不重复的。
+ 这个特性可以轻松地实现数组去重。

### Map是什么，有什么作用？

+ Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。
+ 可以更加全面的描述对象的属性。

### Set 和 Map有什么区别？

+ Map是键值对，Set是值得集合，当然键和值可以是任何得值
+ Set的属性方法有size|add()|has()|delete()|clear()，Map属性方法有size|set()|get()|has()|delete()|clear()
+ Map可以通过get方法获取值，而set不能因为它只有值
+ 都能通过迭代器进行for...of 遍历
+ Set的值是唯一的可以做数组去重，而Map由于没有格式限制，可以做数据存储

### Set、WeakSet和Map、WeakMap的区别

https://www.cnblogs.com/jiajia-hjj/p/15270129.html

**Set**：集合, 类似于数组

- 成员唯一、无序且不重复
- [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
- 可以遍历，方法有：add、delete、has、clear，属性有size

**WeakSet**

- 成员都是对象

- 成员都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成**内存泄漏**

  (*内存泄漏：内容节点不会删掉，内存被没有用的东西占用，就会感觉内存越来越小，因为垃圾挤占了空间，感觉内存是不是丢了)；

- 使用场景：**节点保存**

- 不能遍历，方法有add、delete、has

**Map**

- 字典，本质上是键值对的集合
- 可以遍历，方法很多可以跟各种数据格式转换

**WeakMap**

- 只接受对象作为键名（null除外），不接受其他类型的值作为键名
- 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的，不容易造成**内存泄漏**
- 不能遍历，方法有get、set、has、delete、clear
- 使用场景：**点作为键名、部署私有属性**

### Proxy是什么，有什么作用？

+ Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理
+ 用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。
+ 比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。
+ 下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数。

```js
function createMyOwnObj() {
 //想把所有的key都变成函数，或者Promise,或者anything
 return new Proxy({}, {
  get(target, propKey, receiver) {
   return new Promise((resolve, reject) => {
    setTimeout(() => {
     let randomBoolean = Math.random() > 0.5;
     let Message;
     if (randomBoolean) {
      Message = `你的${propKey}运气不错，成功了`;
      resolve(Message);
     } else {
      Message = `你的${propKey}运气不行，失败了`;
      reject(Message);
     }
    }, 1000);
   });
  }
 });
}

let myOwnObj = createMyOwnObj();

myOwnObj.hahaha.then(result => {
 console.log(result) //你的hahaha运气不错，成功了
}).catch(error => {
 console.log(error) //你的hahaha运气不行，失败了
})

myOwnObj.wuwuwu.then(result => {
 console.log(result) //你的wuwuwu运气不错，成功了
}).catch(error => {
 console.log(error) //你的wuwuwu运气不行，失败了
})
```

### Reflect是什么，有什么作用？

+ Reflect是ES6引入的一个新的对象，他的主要作用有两点，
+ 一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。
+ 其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API。

### Promise是什么，有什么作用？

+ 主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”
+ 它并不是什么突破性的API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。

### Promise是什么?

+ Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；
+ 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。
+ promise有三种状态： pending(等待态)，fulfiled(成功态)，rejected(失败态) ；
+ 状态一旦改变，就不会再变。
+ 创造promise实例后，它会立即执行。

```js
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";
function MyPromise(fn) {
  // 保存初始化状态
  var self = this;
  // 初始化状态
  this.state = PENDING;
  // 用于保存 resolve 或者 rejected 传入的值
  this.value = null;
  // 用于保存 resolve 的回调函数
  this.resolvedCallbacks = [];
  // 用于保存 reject 的回调函数
  this.rejectedCallbacks = [];
  // 状态转变为 resolved 方法
  function resolve(value) {
    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变
    if (value instanceof MyPromise) {
      return value.then(resolve, reject);
    }
    // 保证代码的执行顺序为本轮事件循环的末尾
    setTimeout(() => {
      // 只有状态为 pending 时才能转变，
      if (self.state === PENDING) {
        // 修改状态
        self.state = RESOLVED;
        // 设置传入的值
        self.value = value;
        // 执行回调函数
        self.resolvedCallbacks.forEach(callback => {
          callback(value);
        });
      }
    }, 0);
  }
  // 状态转变为 rejected 方法
  function reject(value) {
    // 保证代码的执行顺序为本轮事件循环的末尾
    setTimeout(() => {
      // 只有状态为 pending 时才能转变
      if (self.state === PENDING) {
        // 修改状态
        self.state = REJECTED;
        // 设置传入的值
        self.value = value;
        // 执行回调函数
        self.rejectedCallbacks.forEach(callback => {
          callback(value);
        });
      }
    }, 0);
  }
  // 将两个方法传入函数执行
  try {
    fn(resolve, reject);
  } catch (e) {
    // 遇到错误时，捕获错误，执行 reject 函数
    reject(e);
  }
}
MyPromise.prototype.then = function(onResolved, onRejected) {
  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数
  onResolved =
    typeof onResolved === "function"
      ? onResolved
      : function(value) {
          return value;
        };
  onRejected =
    typeof onRejected === "function"
      ? onRejected
      : function(error) {
          throw error;
        };
  // 如果是等待状态，则将函数加入对应列表中
  if (this.state === PENDING) {
    this.resolvedCallbacks.push(onResolved);
    this.rejectedCallbacks.push(onRejected);
  }
  // 如果状态已经凝固，则直接执行对应状态的函数

  if (this.state === RESOLVED) {
    onResolved(this.value);
  }

  if (this.state === REJECTED) {
    onRejected(this.value);
  }
};
```

### Iterator是什么，有什么作用？(重要)

+ 不是对象，也不是任何一种数据类型。
+ 因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历
+ 解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念。
+ JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。
+ Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器。
  + (标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)

```js
//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。
//obj.[Symbol.iterator]() 就是Iterator遍历器
let obj = {
  data: [ 'hello', 'world' ],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};
```

+ ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的。

```js
//Array
let array = ['red', 'green', 'blue'];
array[Symbol.iterator]() //Iterator遍历器
array[Symbol.iterator]().next() //{value: "red", done: false}

//String
let string = '1122334455';
string[Symbol.iterator]() //Iterator遍历器
string[Symbol.iterator]().next() //{value: "1", done: false}

//set
let set = new Set(['red', 'green', 'blue']);
set[Symbol.iterator]() //Iterator遍历器
set[Symbol.iterator]().next() //{value: "red", done: false}

//Map
let map = new Map();
let obj= {map: 'map'};
map.set(obj, 'mapValue');
map[Symbol.iterator]().next()  {value: Array(2), done: false}
```



### for...in 和for...of有什么区别？

+ ES6规定，有所部署了载了Iterator接口的对象(可遍历对象)都可以通过for...of去遍历，而for..in仅仅可以遍历对象。
+ 这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习。
+ 上面提到的扩展运算符本质上也就是for..of循环的一种实现。

### Generator函数是什么，有什么作用？

+ 如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。

+ 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。
+ Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。
+  Thunk 函数：目的就是将多参数函数（入参中包含了callback函数）变成单参数版本的函数 

### async函数是什么，有什么作用？

答：async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案。

附录：[手写async await的最简实现（20行搞定）！阿里字节面试必考](http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650079079&idx=2&sn=9eede14eaa71459e0854de70a44585d4&chksm=83da6202b4adeb1408232a8db0b3e6d470564fce73b63c4618d9e2303fec7ef34d8f33eb38cf&scene=21#wechat_redirect)

###  async/await 和 Promise 的关系

- async/await 是消灭异步回调的终极武器。
- 但和 Promise 并不互斥，反而，两者相辅相成。
- 执行 async 函数，返回的一定是 Promise 对象。
- await 相当于 Promise 的 then。
- try...catch 可捕获异常，代替了 Promise 的 catch。



### Class、extends是什么，有什么作用？

+ ES6 的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。
+ 它参考了java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。
+ Class类可以通过extends实现继承。它和ES5构造函数的不同点：

**a**. 类的内部定义的所有方法，都是不可枚举的。

```js
//ES5
function ES5Fun (x, y) {
    this.x = x;
    this.y = y;
}
ES5Fun.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ')';
}
var p = new ES5Fun(1, 3);
p.toString();
Object.keys(ES5Fun.prototype); //['toString']

//ES6
class ES6Fun {
    constructor (x, y) {
        this.x = x;
        this.y = y;
    }
    toString () {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

Object.keys(ES6Fun.prototype); //[]
```

**b**.ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行。

**c**.ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。

**d**.ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

### module、export、import是什么，有什么作用？

+ module、export、import是ES6用来统一前端模块化方案的设计思路和实现方案。
+ export、import的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的AMD/CMD、requireJS、seaJS、commondJS等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS也能更加能实现大型的应用程序开发。

+ import引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。

+ import引入export导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

### 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？

1. 常用箭头函数来取代`var self = this;`的做法。

2. 常用let取代var命令。

3. 常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。

4. 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。

5. 用Class类取代传统的构造函数，来生成实例化对象。

6. 在大型应用开发中，要保持module模块化开发思维，分清模块之间的关系，常用import、export方法。

   

   
   

## 六、jQuery

1、效果

## 七、编程算法

### 10、instanceof

+ **instanceof**：能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**

```js
arr.__proto__ === Array.prototype; // true
```

```js
function myInstanceof(target, origin) {
  if (typeof target !== "object" || target === null) return false;
  if (typeof origin !== "function")
    throw new TypeError("origin must be function");
  let proto = Object.getPrototypeOf(target); // 相当于 proto = target.__proto__;
  while (proto) {
    if (proto === origin.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

myInstanceof([], Array)
```

### 11、数组扁平化

```js
//es6  flat
[1, [2, 3, [4, 5]]].flat(Infinity);//[1, 2, 3, 4, 5]
//普通
function flag(arr){
    while(arr.some(item=>Array.isArray(item))){
        arr=[].concat(...arr);
        console.log(arr)
    }
    return arr
}
//可以指定扁平化的深度
function flat(arr, depth = 1) {
  if (depth > 0) {
    // 以下代码还可以简化，不过为了可读性，还是....
    return arr.reduce((pre,cur)=>{
       return pre.concat(Array.isArray(cur)?flat(cur, depth - 1):cur) 
    },[])
  }
  //为什么不是arr，而是arr.slice()。因为返回一个新的数组
  return arr.slice();
}
flat([1, [2, 3, [4, 5]]],2);//[1, 2, 3, 4, 5]

```

### 12、手写Promise/A

https://juejin.cn/post/6945319439772434469#heading-27

**Promise/A+规范**

+ 不管进行什么操作都返回一个promise对象，这个对象里面会有一些属性和方法

+ 这个promise有三种状态；Unfulfilled（未完成，初始状态）、Fulfilled（已完成）、Failed（失败、拒绝）

+ 这个promise对象的使用时通过then方法进行的调用

```js
// MyPromise.js
// 先定义三个常量表示状态
const PENDING='pending';
const FULFILLED='fulfilled';
const REJECTED='rejected';
// 新建 MyPromise 类
class MyPromise{
    constructor(executor){
        // executor 是一个执行器，进入会立即执行
    // 并传入resolve和reject方法
        executor(this.resolve,this.reject)
    }
    // 储存状态的变量，初始值是 pending
    status = PENDING;
    // 成功之后的值
    value = null;
    // 失败之后的原因
    reason = null;
      // resolve和reject为什么要用箭头函数？
      // 如果直接调用的话，普通函数this指向的是window或者undefined
      // 用箭头函数就可以让this指向当前实例对象
      //this不看调用者。而是看定义它时**所在的作用域**;普通函数this看调用者
      
    // 存储成功回调函数
   onFulfilledCallbacks = [];
    // 存储失败回调函数
   onRejectedCallbacks = [];

     // 更改成功后的状态
    resolve=(value)=>{
        // 只有状态是等待，才执行状态修改
        if(this.status==PENDING){
            // 状态修改为成功
            this.status=FULFILLED;
             // 保存成功之后的值
            this.value=value;
            // ==== 新增 ====
            // 判断成功回调是否存在，如果存在就调用
            while(this.onFulfilledCallbacks){
                // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空
                this.onFulfilledCallbacks.shift()(value);
            }
        }
    }
    // 更改失败后的状态
    reject=(reason)=>{
         // 只有状态是等待，才执行状态修改
        if(this.status==PENDING){
            // 状态成功为失败
            this.status=REJECTED;
            // 保存失败后的原因
            this.reason=reason;
            // ==== 新增 ====
            // 判断失败回调是否存在，如果存在就调用
            while(this.onRejectedCallbacks.length){
                // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空
                 this.onRejectedCallbacks.shift()(reason);
            }
        }
    }
    then(onFulfilled,onRejected){
          // 判断状态
         if(this.status==FULFILLED){
              // 调用成功回调，并且把值返回
             onFulfilled(this.value);
         }else if (this.status === REJECTED) {
             // 调用失败回调，并且把原因返回
             onRejected(this.reason);
         }else if (this.status === PENDING) {
            // ==== 新增 ====
            // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来
            // 等到执行成功失败函数的时候再传递
           this.onFulfilledCallbacks.push(onFulfilled);
          this.onRejectedCallbacks.push(onRejected);
         }
    }
}

//测试1：
const promise = new MyPromise((resolve, reject) => {
   resolve('success')
   reject('err')
})

promise.then(value => {
  console.log('resolve', value)
}, reason => {
  console.log('reject', reason)
})

// 执行结果：resolve success

//测试2：有异步请求
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 2000); 
})


```

### 13、使用Promise实现每隔1秒输出1,2,3

```js
//async/await和Promise
async function f1(){
    await new Promise(resolve=>{
        setTimeout(() => {
            resolve(console.log(1));
        }, 1000)
    })
    await new Promise(resolve=>{
        setTimeout(() => {
            resolve(console.log(2));
        }, 1000)
    })
    await new Promise(resolve=>{
        setTimeout(() => {
            resolve(console.log(3));
        }, 1000)
    })
}

var arr = [1, 2, 3, 4]
async function f2(){
    for(let i=0;i<arr.length-1;i++){
       await new Promise((resolve) => {
            setTimeout(() => {
                console.log(arr[i])
                resolve()
            }, 5000)
        })
    }
}
f2()

//可以用Promise配合着reduce不停的在promise后面叠加.then
const arr = [1, 2, 3]
arr.reduce((p, x) => {
  return p.then(() => {
    return new Promise(r => {
      setTimeout(() => r(console.log(x)), 1000)
    })
  })
}, Promise.resolve())


//5s后打印 1 2 3
const arr = [1, 2, 3]
const result =  arr.reduce((p, x) => {
    return p.then(new Promise(r=>{
        setTimeout(() => r(console.log(x)), 5000)
    }))
}, Promise.resolve())

```

### 14、使用Promise实现红绿灯交替重复亮

红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：

```js
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
const light = function (timer, cb){
    return new Promise(resolve=>{
        setTimeout(() => resolve(cb()), timer)
    })
}
const step = function () {
    Promise.resolve().then(()=>{
        return light(3000,red);
    }).then(()=>{
         return light(2000,yellow);

    }).then(()=>{
        return  light(1000,green);
    }).then(()=>{
        step();
    })
}

step();


```

### 15、 实现mergePromise函数

实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。

```js
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise (ajaxArray) {
  // 在这里写代码
   // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax => {
  	// 第一次的then为了用来调用ajax
  	// 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res => {
      data.push(res);
      return data; // 把每次的结果返回
    })
  })
  // 最后得到的promise,最后一个then的值就是data
  return promise;
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]


```

### 16、封装一个异步加载图片的方法

```js
function loadImg(url) {
    return new Promise((resolve,reject)=>{
        const img=new Image();
        img.onload=function(){
          console.log("一张图片加载完成");
          resolve(img);
        }
        img.onerror=function(){
            reject(new Error('Could not load image at' + url))
        }
        img.src=url;
    })
}

```

### 17、限制异步操作的并发个数并尽可能快的完成全部

+ 可以先请求`urls`中的前面三个(下标为`0,1,2`)，并且请求的时候使用`Promise.race()`来同时请求
+ 三个中有一个先完成了(如下标为`1`的图片)，我们就把这个当前数组中已经完成的那一项(第`1`项)换成还没有请求的那一项(`urls`中下标为`3`)。

```js
function limitLoad(urls, handler, limit) {
    let sequence = [].concat(urls); // 复制urls
    // 这一步是为了初始化 promises 这个"容器"
    let promises = sequence.splice(0, limit).map((url, index) => {
        return handler(url).then(() => {
            // 返回下标是为了知道数组中是哪一项最先完成
            return index;
        });
    });
    // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用
    return sequence
        .reduce((pCollect, url) => {
        return pCollect
            .then(() => {
            return Promise.race(promises); // 返回已经完成的下标
        })
            .then(fastestIndex => { // 获取到已经完成的下标
            // 将"容器"内已经完成的那一项替换
            promises[fastestIndex] = handler(url).then(
                () => {
                    return fastestIndex; // 要继续将这个下标返回，以便下一次变量
                }
            );
        })
            .catch(err => {
            console.error(err);
        });
    }, Promise.resolve()) // 初始化传入
        .then(() => { // 最后三个用.all来调用
        return Promise.all(promises);
    });
}
limitLoad(urls, loadImg, 3)
    .then(res => {
    console.log("图片全部加载完毕");
    console.log(res);
})
    .catch(err => {
    console.error(err);
});


```

### 18、实现一个 Promise.all

## 八、浏览器

### **1、从浏览器地址栏输入 url 到请求返回发生了什么**

+ 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
+ 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到下步操作。
  + 强缓存。
  + 协商缓存。
+ DNS域名解析：通过域名找到对应的服务器，查询 URL 对应的 IP 
+ TCP 连接，三次握手
+ 开始发送 HTTP 请求报文
+ 服务器处理请求并返回 HTTP 报文
+ 浏览器渲染页面。
+ 当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。



### 2、**TCP三次握手**

+ 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口`（第一次握手，由浏览器发起，告诉服务器我要发送请求了）`====>确认客服端的**发送能力**
+ 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息`（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）`===>服务端的**发送能力和接收能力**
+ 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”`（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）`====>客户端的**接收能力**

### 3、**TCP四次挥手**

+ 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。 `(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)`
+ 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。 `(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)`
+ 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。 `(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)`
+ 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。 `(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)`

### 4、**浏览器渲染机制？**

+ 解析：`HTML`-->`DOM`(DOM规则树)，`CSS`--->`CSSOM`(CSS规则树)
+ 结合：`DOM`和`CSSOM`合并就产生了渲染树（`Render Tree`；
+ 布局：渲染树-->知道了所有节点的样式--->计算大小和位置
+ 节点绘制到页面

https://www.cnblogs.com/jiajia-hjj/p/15400057.html

### 5、**重排（reflow）和重绘（repaint）的理解**

+ **重排**（回流）：影响了元素的**几何信息**(元素在视口内的位置和尺寸大小)，，浏览器需要**重新计算**元素在视口内的几何属性。

+ **重绘**：几何属性或者样式发生改变，将渲染树的每个节点都转换为屏幕上的**实际像素**。

### 6、如何做好不频繁触发浏览器的回流与重绘？

**css**

- **使用 `transform` 替代 `top`**、`left`

- **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者改变了布局会引发回流。

- **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

- **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

- **避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

- **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 [requestAnimationFrame](https://www.cnblogs.com/jiajia-hjj/p/15405720.html)。

- **避免使用`CSS`表达式**，可能会引发回流。

- 将频繁重绘或者回流的节点设置为图层

  ，图层能够阻止该节点的渲染行为影响别的节点，浏览器什么时候会创建一个独立的复合图层呢？

  - `video`、`iframe`、`canvas`等标签
  - will-change
  - 3D 或者 CSS transform
  - 元素覆盖时，比如使用了 `z-index` 属性...浏览器会自动将该节点变为图层。

- **CSS3 硬件加速（GPU加速）**，使用css3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。(见6.2)

**js**

- **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。(cssText)
- **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。
- **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

### 7、浏览器内核（渲染引擎）

https://www.cnblogs.com/jiajia-hjj/p/15395960.html

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程



### 8、Event Loop

+ 宏任务队列(macr)：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等
+ 微任务队列(micro)：new Promise().then(回调)、MutationObserver(html5新特性) 

+ 过程：
  + micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）
  + 全局上下文（script 标签）被推入执行栈，同步代码执行
  + 在执行的过程中，在执行的过程中，会判断是同步任务还是异步任务，可以产生新的 macro-task 与 micro-task，分别被推入各自的任务队列
  + 同步代码执行完了，script 脚本会被移出 macro 队列（是队列的 macro-task 的执行和出队的过程）
  + 会查看是否有micro队列，有，处理micro队列中的所有任务；没有，会读取macro 队列中排在最前的任务
  + 执行渲染操作，更新界面
  + 检查是否存在 Web worker 任务，如果有，则对其进行处理
+ 上述过程循环往复，直到两个队列都清空

+ macro-task 出队时，任务是**一个一个**执行的；而 micro-task 出队时，任务是**一队一队**执行的。

###  9、浏览器的垃圾回收机制(GC)

**1)有两种垃圾回收策略：**

- **标记清除**：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
- **引用计数**：它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

**标记清除的缺点：**

- **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
- **分配速度慢**，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

**标记整理（Mark-Compact）算法 **

+ 解决标记清除空闲内存不连续问题
+ 标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

**引用计数的缺点：**

- 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。
- 解决不了循环引用导致的无法回收问题。

**引用计数的缺点：**

- 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。
- 解决不了循环引用导致的无法回收问题。

**V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化：**

- 针对新生区采用并行回收。
- 针对老生区采用增量标记与惰性回收。（并发标记->并行清理，增量标记）

- 针对新生区采用并行回收。
- 针对老生区采用增量标记与惰性回收。



### 10、内存泄漏

+ 内存泄漏：无用对象内存，没有及时回收时
+ 结果：变慢，崩溃，延迟大等

**内存泄漏包括：**

+ 意外的全局变量，直接赋值，或者通过this绑定到window的全局变量
+ 被遗忘的计时器，或者回调函数或者监听器（相当于是局部作用域链的全局变量，因为这些被遗忘的里面要使用该变量）
+ 脱离DOM的引用（DOM树、字典中）
+ 闭包中重复创建的变量

**避免内存泄漏：**

+ 注意程序逻辑，避免死循环。

+ 减少不必要的全局变量，或者相对作用域链上的全局变量，或者生命周期很长的对象，即时回收。

+ 避免频繁创建过多的对象，用完了记得销毁。

  

前端存储机制

前端缓存/后端缓存

Token-- 服务端身份验证的流行方案

前端埋点

## 九、web存储

https://www.cnblogs.com/jiajia-hjj/p/15207912.html

### 1、cookie

- 本身用于浏览器和 server 通讯。
- 被“借用”到本地存储来的。
- 可用 document.cookie = '...' 来修改。

其缺点：

- 存储大小限制为 4KB。
- http 请求时需要发送到服务端，增加请求数量。
- 只能用 document.cookie = '...' 来修改，太过简陋。

### 2、session

+ session的唯一标识SessionID保存在cookie中，具体的数据则是保存在session中
+ 存储内容类型是个对象
+ 保存在服务器，session的安全性大于cookie

### 3、localStorage 和 sessionStorage

- HTML5 专门为存储来设计的，最大可存 5M。
- API 简单易用， setItem getItem。
- 不会随着 http 请求被发送到服务端。

它们的区别：

- localStorage 数据会永久存储，除非代码删除或手动删除。
- sessionStorage 数据只存在于当前会话，浏览器关闭则清空。
- 一般用 localStorage 会多一些。



### 4、cookie，localStorage，sessionStorage 

- 存储的时间有效期不同 

1. 1. cookie的有效期是可以设置的，默认的情况下是关闭浏览器后失效
   2. sessionStorage的有效期是仅保持在当前页面，关闭当前会话页或者浏览器后就会失效
   3. localStorage的有效期是在不进行手动删除的情况下是一直有效的

- 存储的大小不同 

1. 1. cookie的存储是4kb左右，存储量较小，一般页面最多存储20条左右信息
   2. localStorage和sessionStorage的存储容量是5Mb

- 与服务端的通信 

1. 1. cookie会参与到与服务端的通信中，一般会携带在http请求的头部中，例如一些关键密匙验证等。
   2. localStorage和sessionStorage是单纯的前端存储，不参与与服务端的通信

- 读写操作的便捷程度 
- 对于浏览器的支持 

1. 1. cookie出现的时间较早，目前见到的浏览器都支持
   2. localStorage和sessionStorage出现的时间较晚，对于版本较低的浏览器不支持(比如IE8版本以下的都不支持)

### localStorage  sessionStorage  cookies 有什么区别?

+ localStorage:以键值对的方式存储、储存时间没有限制、永久生效、除非自己删除记录
+ sessionStorage：当页面关闭后被清理、与其他相比不能同源窗口共享、是会话级别的存储方式
+ cookies：数据不能超过4k、同时因为每次http请求都会携带cookie 、所有cookie只适合保存很小的数据、如会话标识

### cookie和token的区别

**cookie验证**

+ cookie验证是在用户验证时生成用户的唯一标识sessionld并存储再服务端，服务端将sessionld通过set-cookie头部传给客户端保存到cookie中。

 **token验证**

+ 用户登录成功时，服务器会返回一个加密的token，token存储在客户端，当再次发送请求时，将token
  放在Authorization header中，服务器对token进行验正，如果匹配则返回数据

**区别：**

+ cookie是有状态的，token是无状态的，服务端不需要存储token，只需验证token是否正确
+ token支持跨域访问，而cookie不支持跨域访问
+ 使用token可以避免CSRF攻击，因为不依赖于cookie

## 十、Http

### **1、http状态码及其含义**

- 1XX：信息状态码，服务器收到请求。

- - 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

- 2XX：成功状态码

- - 200 -OK 客户端请求成功 
  - 201 Created -请求成功并且服务器创建了新的资源
  - 202 Accepted -服务器已接受请求，但尚未处理

- 3XX：重定向

- - 301 Moved Permanently -永久重定向，请求的网页已永久移动到新位置。
  - 302 Found- 临时性重定向。
  - 303 See Other- 临时性重定向，且总是使用 GET 请求新的 URI。
  - 304 Not Modified -自从上次请求后，请求的网页资源未被修改。

- 4XX：客户端错误

- - 400 Bad Request- 客户端请求有语法错误，服务器无法理解 。
  - 401 Unauthorized -请求未授权 ，这个状态代码必须和WWW-Authenticate报头域一起使用 。
  - 403 Forbidden -没权限，禁止访问。 服务器收到请求，但是拒绝提供服务 。
  - 404 Not Found -找不到如何与 URI 相匹配的资源。

- 5XX: 服务器错误

- - 500 Internal Server Error- 最常见的服务器端错误。
  - 503 Service Unavailable- 服务器端暂时无法处理请求（可能是过载或维护）。
  - 504 - 网关超时。

### 2、http 缓存

https://www.cnblogs.com/jiajia-hjj/p/15207908.html

- 关于缓存的介绍。
- http 缓存策略（强制缓存 + 协商缓存）。
- 刷新操作方式，对缓存的影响。

**1） 关于缓存**

+ 什么是缓存？ 把一些不需要重新获取的内容再重新获取一次

+ 为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

+ 哪些资源可以被缓存？ 静态资源，比如 js css img。

**2） 强制缓存**

**三种情况：**

+ 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求。
+ 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
+ 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff1ec224244427ba9f15abecbd668fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 1.png" style="zoom: 50%;" />

**Expires**：缓存的到期时间，不好因为（客户端和服务端有一方的时间不准确）会发生误差

**Cache-Control：**

- 在 Response Headers 中。
- 控制强制缓存的逻辑。
- 例如 Cache-Control: max-age=3153600（单位是秒）

**Cache-Control 有哪些值：**

- max-age：缓存最大过期时间。
- no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
- no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

**3） 协商缓存（对比缓存）**

- 服务端缓存策略。
- 服务端判断客户端资源，是否和服务端资源一样。
- 一致则返回 304，否则返回 200 和最新的资源。

![图片 2.png](img/面试题/56e265f46c80430fbf4673878a27bfc9_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp) 资源标识：

- 在 Response Headers 中，有两种。
- Last-Modified：资源的最后修改时间。
- Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。

**Last-Modified：** ![图片 3.png](img/面试题/4c4f44afeb73464295e9878d2c47b024_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp) 服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。

**Etag：** ![图片 4.png](img/面试题/e35285a8d23a4a4380676aeb681e815d_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp) 其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。

**两者比较：**

- 优先使用 Etag。
- Last-Modified 只能精确到秒级。
- 如果资源被重复生成，而内容不变，则 Etag 更精确。

**4） 综述**

+ 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存
+ 若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)
+ 协商缓存由服务器决定是否使用缓存
+ 若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存



+ 缓存不存在，直接发请求获取资源。
+ 缓存存在，cache-control没有过期，读取缓存
+ 缓存存在，cache-control过期，携带 If-None-Match(Etag)向服务器请求，如果资源更新，返回200，加载页面
+ 缓存存在，cache-control过期，携带 If-None-Match(Etag)向服务器请求，如果资源没有更新，返回304，使用缓存

**5） 三种刷新操作对 http 缓存的影响**

正常操作：地址栏输入 url，跳转链接，前进后退等。

手动刷新：f5，点击刷新按钮，右键菜单刷新。

强制刷新：ctrl + f5，shift+command+r。

+ 正常操作：强制缓存有效，协商缓存有效。 
+ 手动刷新：强制缓存失效，协商缓存有效。
+ 强制刷新：强制缓存失效，协商缓存失效。

### 3、 GET 和 POST 的区别。

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，保留在浏览器的历史记录中，而 POST 默认不会。
- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，且参数的长度也有限制（2048字符），POST 放在请求体中，更适合传输敏感信息，参数没有长度限制。
- 从**幂等性**的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

+ get请求一般用来请求获取数据 post请求一般作为发送数据到后台，传递数据，创建数据
+ get请求刷新浏览器或者回退没有影响 post请求则会重新请求一遍
+ get请求通常是通过url地址请求 post常见的则是form表单请求

### 4、HTTP/2 有哪些改进？（很大可能问原理）

- 头部压缩。
- 多路复用。
- 服务器推送。



###  OSI网路七层模型，HTTP、webSocket分别再哪一层

+ 应用层

### 5、跨域问题

#### **CORS**

+ 跨来源资源共享
+ 基本思想：使用额外的HTTP头部让浏览器与服务器进行沟通，从而决定是否接受跨域请求
+ 浏览器在跨域访问时，会自动添加HTTP头信息，或者发起预检请求
+ 关键在于服务器是否做了CORS配置，允许跨域访问。





### 6、Token-- 服务端身份验证的流行方案

### 7、前端埋点

### 8、每个页面需要计算浏览轨迹，怎么实现

## 前端安全问题

### 

## 兼容问题

1. 选择技术框架/库(jquery)帮助我们把兼容性解决
2. 使用辅助性的工具，比如说css重置以及h5的设置(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)
3. 条件注释、CSS Hack、js 能力检测做一些修补
4. 思维方式上，可以使用渐进增强或优雅降级的方式去对浏览器的兼容问题做相对应的操作

## 适配方案

1、一屏适配

2、数据大屏适配

3、什么是栅格设计？



## 其他

### 当你点击搜索按钮时页面没反应，你该怎么排查，说出思路！

+ (1)点击搜索，检查搜索请求事件是否执行
+ (2) 查看控制台，如果控制台有报错信息，如果有就是前端的问题
+ (3)打开F12浏览器开发者工具，查看响应状态码，如果响应状态码为400，表示访问请求语法有误，服务器不能识别，403表示访问请求被禁止，404表示请求的资源不存在，500表示服务器内部出错，无法完成请求，503表示服务器不可用
+ (4)打开F12浏览器开发者工具，检查搜索请求的请求参数和请求数据，如果请求参数或请求数据出错，为前端的问题，如果正确，检查搜索请求的响应数据，如果响应数据出错，为后端的问题



## 说一下常见的git操作

```js
git branch 查看本地所有分支
git status 查看当前状态 
git commit 提交 
git branch -a 查看所有的分支
git branch -r 查看远程所有分支
git commit -am "init" 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow
git push origin master 将文件给推到服务器上 
git remote show origin 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联 
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev
git merge origin/dev 将分支dev与当前分支进行合并
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m "This is the message describing the commit" 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m "remove" 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来


```





